# 动态规划之换钱次数

## 1. 题目
给定数组arr,arr中所有的值中都为正数且不重复。每个值代表一种面值的货币，每种货币可以使用任意张，再给定一个整数aim代表要找的钱数，例如arr=[5,10,25,1],aim=1000

## 2. 解题方法

![动态规划之换钱次数](http://www.bcoder.top/img/interview/73.png)

## 3. 暴力搜索方法

![动态规划之换钱次数](http://www.bcoder.top/img/interview/74.png)

实现代码：

```java
public static void main(String[] args) {
    Test2 test2 = new Test2();
    int[] arr = {5, 10, 25, 1};
    int aim = 1000;
    System.out.println(test2.coins(arr, aim));

}

public int coins(int[] arr, int aim) {

    //判断面值的种类和换钱数是否符合规范，不符合，则为0
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }

    return process1(arr, 0, aim);

}

private int process1(int[] arr, int index, int aim) {

    int res = 0;

    //递归到最后一个，看是否正好换完钱
    if (index == arr.length) {
        if (aim == 0) {
            res = 1;
        } else {
            res = 0;
        }
    } else {
        for (int i = 0; arr[index] * i <= aim; i++) {
            res += process1(arr, index + 1, aim - arr[index] * i);
        }
    }
    return res;
}
```



输出结果：
```
142511
```

## 4. 记忆搜索方法
在上面的process1(arr, index, aim)方法中，arr是一直不变的，我们可以把该方法看成process1(index,aim)。

如果已经使用0张5元和1张10元的情况下，后续将求process1(2,990);

如果已经使用了2张5元和0张10元的情况，后续将求process1(2,990);

这两种情况会出现重复计算，因此，我们可以将process1(2,990)的结果记下来，这就是记忆搜索的方法


```java
//记忆搜索方法
public class Test3 {

    public static void main(String[] args) {
        Test3 test2 = new Test3();
        int[] arr = {5, 10, 25, 1};
        int aim = 1000;
        System.out.println(test2.coins(arr, aim));


    }

    public int coins(int[] arr, int aim) {
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        int[][] map = new int[arr.length + 1][aim + 1];
        return process1(arr, 0, aim, map);

    }

    private int process1(int[] arr, int index, int aim, int[][] map) {
        int res = 0;
        if (index == arr.length) {
            if (aim == 0) {
                res = 1;
            } else {
                res = 0;
            }
        } else {
            int mapValue = 0;
            for (int i = 0; arr[index] * i <= aim; i++) {
                mapValue = map[index + 1][aim - arr[index] * i];

                //查看是否已经计算过index + 1、aim - arr[index] * i
                if (mapValue != 0) {
                    //查看是不符合
                    if (mapValue != -1) {
                        res += mapValue;
                    }
                } else {
                    //没计算过，进行计算
                    res += process1(arr, index + 1, aim - arr[index] * i, map);
                }
            }
        }

        //将结果存入到Map中
        if (res == 0) {
            map[index][aim] = -1;
        } else {
            map[index][aim] = res;
        }
        return res;
    }


}

```

## 5. 动态规划方法

### 5.1. 什么是动态规划方法？
1.其本质是利用申请的空间来记录每一个暴力搜索的计算结果，下次要用结果的时候直接使用，而不是进行重复的递归过程。

2.动态规划规定每一种递归状态的计算顺序，依次进行计算。

### 5.2. 记忆搜索方法与动态规划方法的联系

1.记忆化搜索方法就是某种形态的动态规划方法。

2.记忆化搜索方法不关心到达某一递归过程的路径，只是单纯的对计算过的递归过程进行记录，避免重复计算的递归过程。

3.动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后面的计算过程严格依赖前面的计算过程

4.两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序，而记忆搜索不用规定。


![动态规划之换钱次数](http://www.bcoder.top/img/interview/75.png)

实现代码如下所示：

```java
public class Test4 {

    public static void main(String[] args) {

        int[] arr = {5, 10, 25, 1};
        int aim = 1000;
        System.out.println(coins(arr, aim));

    }

    private static int coins(int[] arr, int aim) {
        if (aim < 0 || arr.length == 0 || arr == null) {
            return 0;
        }

        //初始化空间
        int[][] dp = new int[arr.length][aim + 1];

        //枚举
        //枚举第一列
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;
        }

        //枚举第一行
        for (int j = 0; arr[0] * j <= aim; j++) {
            dp[0][arr[0] * j] = 1;
        }

        int num = 0;

        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j <= aim; j++) {
                num = 0;
                for (int k = 0; j - arr[i] * k >= 0; k++) {
                    num += dp[i - 1][j - arr[i] * k];
                }
                dp[i][j] = num;
            }
        }
        return dp[arr.length - 1][aim];
    }
}

```


## 6. 动态规划方法优化

![动态规划之换钱次数](http://www.bcoder.top/img/interview/76.png)

这样空间复杂度由原来的O（N*aim^2）变成了O（N*aim）

代码实现如下：

```java
public class Test5 {
    public static void main(String[] args) {

        int[] arr = {5, 10, 25, 1};
        int aim = 1000;
        System.out.println(coins(arr, aim));

    }

    private static int coins(int[] arr, int aim) {
        if (aim < 0 || arr.length == 0 || arr == null) {
            return 0;
        }

        //初始化空间
        int[][] dp = new int[arr.length][aim + 1];

        //枚举
        //枚举第一列
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;
        }

        //枚举第一行
        for (int j = 0; arr[0] * j <= aim; j++) {
            dp[0][arr[0] * j] = 1;
        }

        int num = 0;

        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j <= aim; j++) {
                if (j - arr[i] >= 0) {
                    dp[i][j] = dp[i-1][j]+dp[i][j-arr[i]];
                }else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[arr.length - 1][aim];
    }
}
```




