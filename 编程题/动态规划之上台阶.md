# 动态规划之上台阶


## 1. 题目

有n级台阶，一个人一次上一级或者两级，问有多少种走法走完n级台阶的方法，此题我们假设上30层台阶有多少种方法。

## 2. 分析

由题目我们很容易得到表达式：


![动态规划之上台阶](http://www.bcoder.top/img/interview/79.png)


## 3. 代码实现

由上述的表达式，我们很容易得到递归的方式的解法（暴力枚举法）

```java
public class Test1 {

    public static void main(String[] args) {
        System.out.println(f(30));
    }

    public static int f(int n) {
        if (n < 1) {
            return 0;
        } else if (n == 2 | n == 1) {
            return n;
        } else {
            return f(n - 1) + f(n - 2);
        }


    }
}
```

输出结果：
```
1346269
```

进一步的我们可以采用记忆化搜索的方式进行优化计算

```java
public class Test2 {

    public static void main(String[] args) {

        int stepNum = 100;
        int[] map = new int[stepNum+1];
        System.out.println(f(stepNum,map));
    }

    public static int f(int n, int[] map) {
        if (n < 1) {
            return 0;
        } else if (n == 2 | n == 1) {
            return n;
        } else {
            if (map[n]!=0){
                return map[n];
            }else {
                map[n]=f(n - 1, map) + f(n - 2, map);
                return map[n];
            }
        }
    }
}
```

进一步，我们可以由前面的状态一步一步得到后面的状态，因此可以顺序的求出台阶的个数（也就是动态规划的方法）

```java
public class Test3 {

    public static void main(String[] args) {

        int stepNum = 30;
        System.out.println(f(stepNum));
    }


    public static int f(int n) {
        if (n < 1) {
            return 0;
        } else if (n == 2 | n == 1) {
            return n;
        } else {
            int a = 1;
            int b = 2;
            boolean c = true;
            for (int i=3;i<n;i++){
                if (c){
                    int temp = a;
                    a = temp +b;
                    c = false;
                }else {
                    int temp = b;
                    b=a+temp;
                    c=true;
                }

            }
            return a+b;
        }
    }
}
```


