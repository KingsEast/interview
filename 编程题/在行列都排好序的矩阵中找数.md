# 在行列都排好序的矩阵中找数


## 【题目】

给定一个有N*M的整型矩阵matrix和一个整数K，matrix的每一行和每一列都是排好序的。实现一个函数，判断K是否在matrix中。

例如：
```
0   1   2   5

2   3   4   7

4   4   4   8

5   7   7   9
```
如果K为7，返回true；如果K为6，返回false。

要求时间复杂度为O(N+M),额外空间复杂度为O(1)。


## 【分析】

1.从矩阵最右上角的数开始寻找（row=0，col=M-1）。

2.比较当前数matrix[row][col]与K的关系：

如果与K相等，说明已经找到，直接但会true。
如果比K大，因为矩阵每一列都已经排好序，所以在当前数所在的列中，处于当前数下方的数都会比K大，则没有必要继续在第col列上寻找，令col--，重复步骤2。
如果比K小，因为矩阵每一行都已经排好序，所以在当前数所在的行中，处于当前数左方的数都会比K大，则没有必要继续在第row行上寻找，令row++，重复步骤2。

3.如果找到越界都没有发现与K相等的数，则返回false。

## 【代码实现】

```java
public class SortTest4 {
    public static void main(String[] args) {
        int[][] matrix = {{0, 1, 2, 5}, {2, 3, 4, 7}, {4, 4, 4, 8}, {5, 7, 7, 9}};


        System.out.println(isContains(matrix,7));
        System.out.println(isContains(matrix,6));


    }

    private static boolean isContains(int[][] matrix, int find) {
        int row = 0;
        int col = matrix.length-1;
        while (row<matrix.length&&col>-1){
            int current =matrix[row][col];
            if(current>find){
                col--;
            }else if (current<find){
                row++;
            }else if (current==find){
                return true;
            }
        }
        return false;
    }
}
```

输出结果：
```
true
flase
```





