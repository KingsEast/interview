# 二叉树的序列化与反序列化问题


## 【题目】


![二叉树的序列化与反序列化问题](http://www.bcoder.top/img/interview/49.png)

遍历的二叉树如下图所示：

![二叉树的序列化与反序列化问题](http://www.bcoder.top/img/interview/50.png)


## 【代码实现】

比如，我们采用先序遍历对二叉树进行序列化，

1.假设序列化的结果是str，初始时str为空字符串。

2. 先序遍历二叉树时如果遇到空节点，在str末尾加上“#!”.

3.如果遇到不为空的节点，假设节点值为3，就在str末尾加上“3!”.

下面来看先序序列化的具体实现：

```java
/**
 * 二叉树的序列化
 */
public class TreeTest3 {


    private static TreeNode<Integer> node1;
    private static TreeNode<Integer> node2;
    private static StringBuffer sb = new StringBuffer();
    static {
        node2 = new TreeNode<>(null,null,3);
        node1 = new TreeNode<>(node2,null,12);
    }

    public static void main(String[] args) {
        preOrderTraverse(node1);
        System.out.println(sb.toString());
    }


    private static void preOrderTraverse(TreeNode root){
        if(root!=null){
            sb.append(""+root.getValue()+"!");
            preOrderTraverse(root.getLeft());
            preOrderTraverse(root.getRight());

        }else {
            sb.append("#!");

        }
    }
}

```

运行结果：
```
12!3!#!#!#!
```


下面来实现一下反序列化，同样的，我们使用前序遍历进行反序列化：

```java

/**
 * 二叉树的反序列化
 */
public class TreeTest4 {

    public static int index = -1;
    
    static TreeNode Deserialize(String str) {
        index++;
        int length = str.length();
        if (index >= length) {
            return null;
        }
        String[] nodeSeq = str.split("!");
        TreeNode pNode = null;
        if (!nodeSeq[index].equals("#")) {
            pNode = new TreeNode(null,null,Integer.valueOf(nodeSeq[index]));
            pNode.setLeft( Deserialize(str));
            pNode.setRight(Deserialize(str));
        }
        return pNode;
    }

    public static void main(String[] args) {
        String str = "12!3!#!#!#!";

        TreeNode treeNode = Deserialize(str);
        preOrderTraverse(treeNode);

    }


    private static void preOrderTraverse(TreeNode root) {
        if (root != null) {
            System.out.println(root.getValue());

            preOrderTraverse(root.getLeft());
            preOrderTraverse(root.getRight());

        }
    }

}

```

运行结果：
```
12
3
```

从这两个例子中，我们可以总结两点：
1.选择用什么样的遍历方式进行序列化，就选择用什么样的方式进行反序列化。

2.一棵二叉树的序列化的结果是唯一的，唯一的结果生成唯一的二叉树也是唯一的。
