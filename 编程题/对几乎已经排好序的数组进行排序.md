# 对几乎已经排好序的数组进行排序


## 【题目】

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。 


## 【分析】

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。

## 【思路】

思路：使用空间复杂度为O（nlogn）中的堆排序，因为快速排序是随机选取一个数然后左右分段，归并排序是分成n个只有一个元素的序列，他们与序列顺序关系不大，选用插入排序的话，时间复杂度为O(n*K),所以选用改进后的堆排序解决。

1.建立由k可元素的小顶堆(小根堆)，然后取出顶上元素

2.堆顶用没有建堆的下一元素替代，重新建堆

3.反复调用，完成排序，此算法因为每个元素移动都在k以内，所以时间复杂度为O（nlogk）


## 【代码实现】

```java

class ScaleSort {  
    public int[] sortElement(int[] A, int n, int k) {  
        if(n == 0 || n < k)  
            return A;  
        int[] heap = Arrays.copyOf(A, k);  
        //建立只有k个元素的小顶堆  
        for(int i = k/2-1;i >= 0;i--)  
            heapCreate(heap,i,k);  
        //核心：建完堆后取出堆顶，赋值给A第一元素，然后用后面从k到n个元素逐布替代  
        for(int i = k;i < n;i++){  
            A[i-k] = heap[0];  
            heap[0] = A[i];  
            heapCreate(heap, 0, k);  
        }  
        //逐步建堆排序结束后，最后还有n-1-k+1到n-1的k个元素的完整堆  
        //用普通堆排序思想输出  
        //堆顶与最后一个元素交换  
        for(int i = n-k;i < n;i++){  
            A[i] = heap[0];  
            //交换  
            int temp = heap[0];  
            heap[0] = heap[k-1];  
            heap[k-1] = temp;  
            //重新调整  
            heapCreate(heap, 0, --k);  
        }  
        return A;  
    }  
    //建小顶堆函数  
    private void heapCreate(int[] heap,int i,int k){  
        int temp = heap[i];  
        for(int j = 2*i+1;j < k; j = 2*j+1){  
            if((j+1 < k)&&(heap[j] > heap[j+1]))  
                j++;  
            if(temp < heap[j])  
                break;  
            heap[i] = heap[j];  
            i = j;  
        }  
        heap[i] = temp;  
    }  
}  
```









