# 简述JVM垃圾回收机制（GC）


Java语言出来之前，大家都在拼命的写C或者C++的程序，而此时存在一个很大的矛盾，C++等语言创建对象要不断的去开辟空间，不用的时候有需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的allocated，然后不停的~析构。于是，有人就提出，能不能写一段程序在实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？

1960年 基于MIT的Lisp首先提出了垃圾回收的概念，用于处理C语言等不停的析构操作，而这时Java还没有出世。所以实际上GC并不是Java的专利，GC的历史远远大于Java的历史。

## 为什么要学习垃圾回收？
1. 排查内存溢出
2. 排查内存泄漏
3. 性能调优，排查并发瓶颈

## 什么时候会触发一个对象的回收的呢？

GC主要处理的是对象的回收操作，那么什么时候会触发一个对象的回收的呢？

大多数对象会很快变得不可达
只有很少的由老对象（创建时间较长的对象）指向新生对象的引用

下面列举一下会发生垃圾收集的情况？

1. 对象没有引用
2. 作用域发生未捕获异常
3. 程序在作用域正常执行完毕
4. 程序执行了System.exit()
5. 程序发生意外终止（被杀进程等）

<br>

## 垃圾收集的主要方法

### System.gc()方法


使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：java -verbosegc classfile    由于这种方法会影响系统性能，不推荐使用，所以不详诉。

 

### finalize()方法

在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：protected void finalize() throws Throwable  


在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。

之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。例如：
1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。
2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。










